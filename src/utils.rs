use blake2::digest::{Update, VariableOutput};
use blake2::Blake2bVar;
use std::cmp::min;

// Helper functions
fn mod_non_power_of_2(hash: &[u8], n: usize) -> usize {
    let epsilon_fail: usize = 1 << 40; // roughly 1 in 10 billion
    let k: usize = log_base2(n * epsilon_fail);
    let k_prime: usize = 1 << k;
    let d: usize = k_prime.div_ceil(n);

    let i = mod_power_of_2(hash, k_prime);

    if i >= d * n {
        panic!("failed: i = {}, d = {}, n = {}, k = {}", i, d, n, k);
    } else {
        i % n
    }
}

fn mod_power_of_2(hash: &[u8], n: usize) -> usize {
    let r = from_bytes_le(hash);
    (n - 1) & r
}

fn log_base2(x: usize) -> usize {
    usize::BITS as usize - x.leading_zeros() as usize - 1
}

fn from_bytes_le(bytes: &[u8]) -> usize {
    let mut array = [0u8; 8];
    let bytes = &bytes[..min(8, bytes.len())];
    array[..bytes.len()].copy_from_slice(bytes);
    usize::from_le_bytes(array)
}

/// Return a 32-byte hash of the given data
pub fn hash_bytes<const N: usize>(data: &[u8]) -> [u8; N] {
    let mut hasher = Blake2bVar::new(N).expect("Failed to construct hasher!");
    hasher.update(data);
    let mut buf = [0u8; N];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}

/// Return 32-byte hash of the given list of data
pub fn combine_hashes<const N: usize>(hash_list: Vec<Vec<u8>>) -> [u8; N] {
    let mut hasher = Blake2bVar::new(N).expect("Failed to construct hasher!");
    for data in hash_list.iter() {
        hasher.update(data);
    }
    let mut buf = [0u8; N];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}

pub fn oracle(hash: &[u8], n: usize) -> usize {
    if n.is_power_of_two() {
        mod_power_of_2(hash, n)
    } else {
        mod_non_power_of_2(hash, n)
    }
}

/// Generate a set of items for given set size
/// Items are generated by hashing the current index
pub fn gen_items<const N: usize>(seed: Vec<u8>, set_size: usize) -> Vec<[u8; N]> {
    let mut s_p = Vec::with_capacity(set_size);
    for b in 0..set_size {
        let mut data = Vec::new();
        data.push(seed.clone());
        data.push(b.to_ne_bytes().to_vec());
        let item = combine_hashes::<N>(data);
        s_p.push(item);
    }
    s_p
}

pub fn format_time(nanos: u128) -> String {
    let mut time = nanos;
    let bounds = [1000, 1000, 1000, 60, 60, 60];
    let units = ["ns", "Î¼s", "ms", "s", "min", "h"];
    for (&bound, &unit) in bounds.iter().zip(units.iter()) {
        if time < bound {
            return time.to_string() + unit;
        }
        time = time / bound;
    }
    (time * 60).to_string() + "h"
}

pub fn format_nb(x: usize) -> String {
    let mut y = x;
    let mut s = String::new();
    let mut b = true;
    while y / 1000 != 0 {
        let to_add = (y % 1000).to_string();
        let preppend = "0".repeat(3 - to_add.len()) + &to_add;
        let append = if b { "" } else { &("_".to_string() + &s) };
        s = preppend + append;
        b = false;
        y = y / 1000;
    }
    if b {
        y.to_string()
    } else {
        (y % 1000).to_string() + "_" + &s
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn test_oracle() {
        // Test distribution of oracle
        assert!(true);
    }
}
