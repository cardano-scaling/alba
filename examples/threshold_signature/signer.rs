use crate::threshold_signature::registration::ClosedRegistration;
use crate::threshold_signature::signature::IndividualSignature;
use blst::min_sig::{PublicKey, SecretKey};
use rand_core::{CryptoRng, RngCore};

/// Threshold signature participant candidate
#[derive(Debug)]
pub struct Candidate {
    /// Signing key of the type blst `SecretKey`
    signing_key: SecretKey,
    /// Signature verification key of the type blst `PublicKey`
    pub verification_key: PublicKey,
}

/// Registered Threshold signature signer.
/// It includes signer's keypair, registration index of the signer, and the registration check-sum.
#[derive(Debug)]
pub struct Signer {
    signing_key: SecretKey,
    verification_key: PublicKey,
    signer_index: usize,
    registration_check_sum: Vec<u8>,
}

impl Candidate {
    /// Generate a new candidate, i.e., a bls signer
    pub fn new(rng: &mut (impl RngCore + CryptoRng)) -> Self {
        let mut ikm = [0u8; 32];
        rng.fill_bytes(&mut ikm);
        let sk = SecretKey::key_gen(&ikm, &[])
            .expect("Error occurs when the length of ikm < 32. This will not happen here.");
        let vk = sk.sk_to_pk();
        Self {
            signing_key: sk,
            verification_key: vk,
        }
    }

    /// Create a new signer from candidate and closed registration
    pub fn new_signer<const N: usize>(
        &self,
        closed_registration: &ClosedRegistration,
    ) -> Option<Signer> {
        closed_registration
            .registered_keys
            .get_index::<N>(&self.verification_key)
            .map(|index| Signer {
                signing_key: self.signing_key.clone(),
                verification_key: self.verification_key,
                signer_index: index,
                registration_check_sum: closed_registration.check_sum.clone(),
            })
    }
}

impl Signer {
    /// Create a bls signature for given message.
    /// Signer creates a commitment by hashing the checksum of the closed registration and the message.
    /// The signature is generated by signing the commitment.
    pub fn sign<const N: usize>(&self, msg: &[u8]) -> IndividualSignature {
        let commitment: [u8; N] =
            ClosedRegistration::get_commitment::<N>(&self.registration_check_sum, msg);

        IndividualSignature {
            signature: self.signing_key.sign(&commitment, &[], &[]),
            verification_key: self.verification_key,
            signer_index: self.signer_index,
        }
    }
}
