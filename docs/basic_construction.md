# Telescope - Basic Construction
**ALBA** provides a method for a prover to convince a verifier that the prover knows strictly more than $n_f$ elements satisfying a predicate $R$, while only presenting a smaller subset of elements as proof. 
This construction uses a recursive filtering process, guided by random oracles, to produce succinct and efficient proofs.

## Overview
The prover constructs a proof by creating tuples (sequences) of elements from $S_p$, the set of known elements. 
1. The process begins by initializing tuples with starting values and expanding them step-by-step during the proof construction process.
2. At each step, the prover extends the current tuple by adding an element from $S_p$ and performs a random oracle check:
   - If the check is successful, the tuple is kept and may be extended further.
   - If the check fails, the tuple is discarded.

This process is guided by a random oracle, which evaluates the validity of each tuple. 
At each step, the random oracle performs a check, and only tuples that satisfy this check are extended further. 
This ensures that the proof construction process proceeds efficiently by discarding invalid tuples early.

The proof construction employs *Depth-First Search (DFS)* over a conceptual tree, where each vertex represents a potential tuple. 
DFS ensures efficiency by systematically exploring valid branches and pruning invalid ones.

### Core Components
- **Parameters**:
  - $d: ~~$ Maximum number of subtrees to search to find a proof.
  - $u: ~~$ The length of the proof tuple generated by the prover.
  - $q: ~~$ The probability that a tuple of full size is selected.
  - $n_p: ~~$ Total number of elements available to the prover.
  - $n_f: ~~$ The lower bound to prove on prover set.

- **Random Oracles**:
  - $H_1: ~~$ A random oracle returning $1$ with probability $1/n_p$, used to probabilistically filter candidate tuples. 
  - $H_2: ~~$ Another random oracle returning $1$ with probability $q$, applied as a final test to determine if a full tuple qualifies as a valid proof.

### The Tree Structure
- Each root $t \in \[d\]$ is treated as the starting node of a tree.
- The tree has $u$ levels, where $u$ is the length of the proof tuple.
- At level $i$, nodes represent tuples of the form $(t, s_1, s_2, \ldots, s_i)$, where $t$ is the root, and $s_1, \ldots, s_i$ are elements.

### Tuple Construction via DFS
- The prover constructs tuples recursively using DFS.
- At each level $i$, the prover:
  - Extends the current tuple by adding an element $s$ from $S_p$.
  - Checks tuple validity using the random oracle $H_1$. A tuple $(t, s_1, \ldots, s_i)$ is valid if $H_1(t, s_1, \ldots, s_i) = 1$.
  - If the tuple fails the $H_1$ check, it is discarded, and the DFS does not explore its descendants.
  - Otherwise, the prover recursively calls DFS on the newly extended tuple to continue the construction process.
- The process continues until a valid tuple of length $u$ is found, or all possibilities are exhausted.

#### Example: how DFS works
- Choose a root $t \in \[d\]$ and initialize the search with $(t)$.
  - At each step, extend the current tuple $(t, s_1, \ldots, s_i)$ by trying every element $s \in S_p$.
  - Check if $H_1(t, s_1, \ldots, s_i) = 1$:
    - If true, recursively extend the tuple.
    - If false, backtrack and try the next candidate for $s_i$.
- Stop when a valid tuple $(t, s_1, \ldots, s_u)$ is found and satisfies $H_2(t, s_1, \ldots, s_u) = 1$.

## The Protocol
### Parameter Generation
The parameter generation process for the basic construction is designed to ensure the protocol achieves the desired levels of *security* and *efficiency*.
The internal parameters of ALBA, such as $u$, $d$, $q$, are computed based on the security parameters, $n_f$, $n_p$ .
- Security parameters:
  - $\lambda_{sec}:$ defines the probability that an adversary, who knows at most $n_f$ elements, can construct a valid proof. It controls the protocol's resistance to adversarial attacks by making forgery negligibly likely.
  - $\lambda_{rel}:$ defines the probability that an honest prover, with knowledge of a sufficiently large set $S_p$, can successfully generate a valid proof. It ensures the practicality of the protocol for honest participants, emphasizing the importance of feasibility in proof construction.
- Relationship between the parameters:
  - The proof length $u$ is directly proportional to the security parameters and inversely proportional to the logarithm of the ratio $n_p / n_f$. 
    - This means that as the prover's set size $n_p$ grows compared to the threshold $n_f$, the required proof length decreases logarithmically, reflecting the reduced adversarial advantage.
      $$
        u \coloneqq \Bigg\lceil \frac{\lambda_{sec} + \log \lambda_{rel} + 1 - \log \log e}{\log (n_p / n_f)}\Bigg\rceil.
      $$
  - The maximum number of subtrees to search $d$ depends linearly on both the proof length $u$ and the security parameter $\lambda_{rel}$. 
    - It directly influences the ability to find a valid proof.
    - Increasing $d$ improves the chances of constructing a valid proof, ensuring robustness in the presence of random oracle checks.
      $$
        d \coloneqq \Bigg\lceil \frac{2 u \lambda_{rel}}{\log e}\Bigg\rceil.
      $$
  - The probability that a tuple of full size is selected $q$ is inversely proportional to $d$, approximating $\lambda_{rel} / d$. 
    - Since $d$ is linked to $u$, $q$ is approximately inversely proportional to $u$.
    
      $$
        q \coloneqq \frac{2 \lambda_{rel}}{d \log e}.
      $$
    
    - A smaller $q$ reduces the chance of accepting invalid proofs, enhancing security, but also decreases the probability of finding a valid proof, necessitating a larger $d$.

### Prover Algorithm
The prover's objective is to convince the verifier that they know a large subset of elements $S_p$, with size exceeding the threshold $n_f$, without revealing the entire set or any specific subset of size greater than $n_f$.
Instead, the prover constructs a compact proof $(t, s_1, ..., s_u)$ that satisfies the following:
- The proof demonstrates that the prover possesses knowledge of a set $S_p$ satisfying a predicate $R$, with the assurance that $|S_p| > n_f$, where $n_f$ is a threshold strictly smaller than $n_p$ and $|S_p| \geq n_p$.
- The prover outputs only a small sequence of $u$ elements from $S_p$, rather than transmitting the full set, ensuring communication efficiency.
- By using random oracles $H_1$ and $H_2$, the prover ensures that:
  - The proof is hard to forge by an adversary who knows at most $n_f$ elements.
  - A prover who knows a subset $S_p$ with size greater than $n_p$ can construct a valid proof with high probability, leveraging the filtering and validation mechanisms of $H_1$ and $H_2$.
- The constructed tuple $(t, s_1, ..., s_u)$ satisfies:
  - $H_1(t, s_1, ..., s_i) = 1$ for all prefixes up to length $u$,
  - $H_2(t, s_1, ..., s_u) = 1$ for the final tuple.

In summary, the prover's task is to use recursive construction via DFS to find and output a valid tuple that demonstrates knowledge of $S_p$ without directly revealing the full set.

### Verifier Algorithm
The verifier's objective is to validate the prover's claim by ensuring that the submitted proof $(t, s_1, ..., s_u)$ satisfies the conditions of the ALBA protocol. Specifically:
- Verify that the proof tuple satisfies the random oracles' checks for both $H_1$ and $H_2$.
 - Check that the proof is well formed, as specified in the protocol.
- The verifier ensures that the proof was generated by a prover possessing a large subset $S_p$. If the prover knows at most $n_f$ elements, the probability of passing verification should be negligible.
- The verifier performs efficient checks proportional to the proof size $u$, making the process scalable.

### Functions
#### Proving
---
> $\mathsf{Prove}(S_p) \rightarrow \pi$
> - Input:
>   - $S_p:~~$ `prover_set`, a set of elements to be proven.
> - Output:
>   - $\pi:~~$ `proof`, a valid proof $(t, s_1, \ldots, s_u)$ or $\bot$.
> ---
> - **for** each $~~ t \in \[1,~ d\]:$
>   - $\pi \leftarrow \mathsf{DFS}(t, \[~\], S_p)$
>   - **if** $~~ \pi ~!= \bot:$
>     - **return** $~~ \pi.$
> - **return** $~~ \bot.$
---

#### Depth-first search
---
> $\mathsf{DFS}(t, slist, S_p) \rightarrow \pi$
> - Input:
>   - $t:~~$ `search_counter`, index of the current subtree being searched.
>   - $slist:~~$ `element_sequence`, candidate element sequence.
>   - $S_p:~~$ `prover_set`, a set of elements to be proven.
> - Output:
>   - $\pi:~~$ `proof`, a valid proof $(t, s_1, \ldots, s_u)$ or $\bot$.
> ---
> - **if** $~~ \mathsf{len}(slist) == u:$
>   - **if** $~~ \mathsf{H_2}(t, slist) == 1:$
>     - $\pi \leftarrow (t, slist)$
>     - **return** $~~ \pi.$
>   - **return** $~~ \bot.$
> - **for** each $~~ s_{new} \in S_p:$
>   - $slist_{new} \leftarrow slist \cup \[s_{new}\]$
>   - **if** $~~ \mathsf{H_1}(t, slist_{new}) == 1:$
>     - $\pi \leftarrow \mathsf{DFS}(t, slist_{new}, S_p)$
>     - **if** $~~ \pi ~!= \bot:$
>       - **return** $~~ \pi.$
> - **return** $~~ \bot.$
---

#### Verification
---
> $\mathsf{Verify}(\pi) \rightarrow 0/1$
> 
> - Input:
>   - $\pi:~~$ `proof`, a proof of the form $(t, s_1, \ldots, s_u)$.
> - Output:
>   - $0/1$.
> ---
> - **if** $~~ t âˆ‰  \[d\]:$
>   - **return** $~~ 0.$
> - **for** each $~~ i \in \[1,~ u\]:$
>   - **if** $~~ \mathsf{H_1}(t, s_1, \ldots, s_i) ~!= 1:$
>     - **return** $~~0.$
> - **return** $~~ \mathsf{H_2}(t, s_1, \ldots, s_u).$
---
