# Telescope - Basic Construction
**ALBA** provides a method for a prover to convince a verifier that the prover knows at least $n_f$ elements satisfying a predicate $R$, while only presenting a small subset of elements as proof. 
This construction uses a recursive filtering process, guided by random oracles, to produce succinct and efficient proofs.

## Overview
- The prover builds a proof by creating tuples (sequences) of elements from $S_p$, the set of elements. 
- The process begins with roots as starting points and expands them step-by-step. 
- At each step, only tuples that satisfy specific conditions, as determined by a random oracle, are kept for further extension.
- The random oracle acts as a filter to ensure that the prover selects only a small subset of elements that is highly unlikely to satisfy the conditions by chance alone.
- The proof construction uses *Depth-First Search (DFS)* over a conceptual tree, where each path represents a potential tuple. 
- The DFS ensures efficiency by pruning invalid branches early.

### Core Components
- **Parameters**:
  - $d: ~~$ Maximum number of subtrees to search to find a proof.
  - $u: ~~$ The length of the proof tuple generated by the prover.
  - $q: ~~$ Probability that a tuple of elements is a valid proof.
  - $n_p: ~~$ Total number of elements available to the prover.
  - $n_f: ~~$ The lower bound to prove on prover set.

- **Random Oracles**:
  - $H_1: ~~$ A random oracle returning $1$ with probability $1/n_p$, used to probabilistically filter candidate tuples. 
  - $H_2: ~~$ Another random oracle returning $1$ with probability $q$, applied as a final test to determine if a tuple qualifies as a valid proof.

### The Tree Structure
- Each root $t \in \[d\]$ is treated as the starting node of a tree.
- The tree has $u$ levels, where $u$ is the length of the proof tuple.
- At level $i$, nodes represent tuples of the form $(t, s_1, s_2, \ldots, s_i)$, where $t$ is the root, and $s_1, \ldots, s_i$ are elements.

### Tuple Construction via DFS
- The prover constructs tuples recursively using DFS.
- At each level $i$, the prover:
  - Extends the current tuple by adding an element $s_{i+1}$ from $S_p$.
  - Checks tuple validity using the random oracle $H_1$. A tuple $(t, s_1, \ldots, s_{i+1})$ is valid if $H_1(t, s_1, \ldots, s_{i+1}) = 1$.
  - If the tuple fails the $H_1$ check, it is discarded, and the DFS does not explore its descendants.
- The process continues until a valid tuple of length $u$ is found, or all possibilities are exhausted.

#### Example: how DFS works
- Choose a root $t \in \[d\]$ and initialize the search with $(t)$.
  - At each step, extend the current tuple $(t, s_1, \ldots, s_i)$ by trying every element $s_{i+1} \in S_p$.
  - Check if $H_1(t, s_1, \ldots, s_{i+1}) = 1$:
    - If true, recursively extend the tuple.
    - If false, backtrack and try the next candidate for $s_{i+1}$.
- Stop when a valid tuple $(t, s_1, \ldots, s_u)$ is found and satisfies $H_2(t, s_1, \ldots, s_u) = 1$.

## The Protocol

### Prover Algorithm
The prover's objective is to convince the verifier that they know a large subset of elements $S_p$ without revealing the entire set.
Instead, the prover constructs a compact proof $(t, s_1, ..., s_u)$ that satisfies the following:
- The proof demonstrates that the prover possesses knowledge of a set $S_p$ satisfying a predicate $R$, with the assurance that $|S_p| > n_f$, where $n_f$ is a threshold strictly smaller than $n_p$ï¿¼and $|S_p| \geq n_p$.
- The prover outputs only a small sequence of $u$ elements from $S_p$, rather than transmitting the full set, ensuring communication efficiency.
- By using random oracles $H_1$ and $H_2$, the prover ensures that:
  - The proof is hard to forge by an adversary who knows fewer than $n_f$ elements.
  - Only the prover, with access to a large $S_p$, can construct a valid proof with high probability.
- The constructed tuple $(t, s_1, ..., s_u)$ satisfies:
  - $H_1(t, s_1, ..., s_i) = 1$ for all prefixes up to length $i$,
  - $H_2(t, s_1, ..., s_u) = 1$ for the final tuple.

In summary, the prover's task is to use recursive construction via DFS to find and output a valid tuple that demonstrates knowledge of $S_p$ without directly revealing the full set.

### Verifier Algorithm
The verifier's objective is to validate the prover's claim by ensuring that the submitted proof $(t, s_1, ..., s_u)$ satisfies the conditions of the ALBA protocol. Specifically:
- Verify that the proof tuple satisfies the required conditions of the random oracles $H_1$ and $H_2$.
  - Ensure that the proof adheres to the structure specified in the protocol.
- The verifier ensures that the proof was generated by a prover possessing a large subset $S_p$. If the prover knows fewer than $n_f$ elements, the probability of passing verification should be negligible.
- The verifier performs efficient checks proportional to the proof size $u$, making the process scalable.

### Functions

#### Proving
---
> $\mathsf{Prove}(S_p) \rightarrow \pi$
> - Input:
>   - $S_p:~~$ `prover_set`, a set of elements to be proven.
> - Output:
>   - $\pi:~~$ `proof`, a valid proof $(t, s_1, \ldots, s_u)$ or $\emptyset$.
> ---
> - **for** each $~~ t \in \[1,~ d\]:$
>   - $\pi \leftarrow \mathsf{DFS}(t, \[~\], S_p)$
>   - **if** $~~ \pi ~=\not \emptyset:$
>     - **return** $~~ \pi.$
> - **return** $~~ \emptyset.$
---

#### Depth-first search
---
> $\mathsf{DFS}(t, slist, S_p) \rightarrow \pi$
> - Input:
>   - $t:~~$ `search_counter`, index of the current subtree being searched.
>   - $slist:~~$ `element_sequence`, candidate element sequence.
>   - $S_p:~~$ `prover_set`, a set of elements to be proven.
> - Output:
>   - $\pi:~~$ `proof`, a valid proof $(t, s_1, \ldots, s_u)$ or $\emptyset$.
> ---
> - **if** $~~ \mathsf{len}(slist) = u:$
>   - **if** $~~ \mathsf{H_2}(t, slist) = 1:$
>     - $\pi \leftarrow (t, slist)$
>     - **return** $~~ \pi.$
>   - **return** $~~ \emptyset.$
> - **for** each $~~ s_{new} \in S_p:$
>   - $slist_{new} \leftarrow slist \cup \[s_{new}\]$
>   - **if** $~~ \mathsf{H_1}(t, slist_{new}) = 1:$
>     - $\pi \leftarrow \mathsf{DFS}(t, slist_{new}, S_p)$
>     - **if** $~~ \pi ~=\not \emptyset:$
>       - **return** $~~ \pi.$
> - **return** $~~ \emptyset.$
---

#### Verification
---
> $\mathsf{Verify}(\pi) \leftarrow 0/1$
> 
> - Input:
>   - $\pi:~~$ `proof`, a proof of the form $(t, s_1, \ldots, s_u)$.
> - Output:
>   - $0/1$.
> ---
> - **if** $~~ t \in\not  \[d\]:$
>   - **return** $~~ 0.$
> - **for** $~~ i = \[1,~ u\]:$
>   - **if** $~~ \mathsf{H_1}(t, s_1, \ldots, s_i) ~=\not 1:$
>     - **return** $~~0.$
> - **return** $~~ \mathsf{H_2}(t, s_1, \ldots, s_u).$
---
