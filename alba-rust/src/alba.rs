extern crate core;
use blake2::digest::{Update, VariableOutput};
use blake2::Blake2bVar;
use num_traits::{Inv, ToPrimitive};
use std::cmp::min;
use std::f64::consts::E;

#[derive(Debug, Clone)]
/// Pre hash of a set item
struct PreHash {
    /// Set item
    s: [u8; 32],
    /// Hash of the set item
    h: Vec<u8>,
    /// oracle(h, n_p)
    l: usize,
}

#[derive(Debug, Clone)]
/// The parameters we check for a round
struct Round {
    t: usize,
    /// Round hash
    h: Vec<u8>,
    /// Round items
    s_list: Vec<[u8; 32]>,
    /// Round n_p
    n_p: usize,
}

#[derive(Debug, Clone)]
struct Proof {
    d: usize,
    items: Vec<[u8; 32]>,
}

#[derive(Debug, Clone)]
struct Verification {
    proof: Proof,
    params: Params,
    valid: bool,
    reason: Option<String>,
}

#[derive(Debug, Clone)]
pub struct Params {
    pub lambda_sec: f64,
    pub lambda_rel: f64,
    pub n_p: usize,
    pub n_f: usize,
}

#[derive(Debug, Clone)]
pub struct AlbaSetup {
    pub n_p: usize,
    pub u: usize,
    pub d: usize,
    pub q: f64,
}

impl AlbaSetup {
    pub fn gen_setup(params: &Params) -> Self {
        let n_p_f64 = params.n_p as f64;
        let n_f_f64 = params.n_f as f64;
        let e = E;
        let log_2 = |x: f64| x.log2();
        let loge = log_2(e);
        let log3 = log_2(3.0);

        let u_prime = (params.lambda_sec + log_2(params.lambda_rel + log3) + 1.0 - log_2(loge))
            / (n_p_f64 / n_f_f64).log(2.0);

        let u = u_prime.ceil() as usize;
        let d = (16.0 * u_prime * (params.lambda_rel + log3) / loge).ceil() as usize;
        let q = 2.0 * (params.lambda_rel + log3) / (d as f64 * loge);

        AlbaSetup {
            n_p: params.n_p,
            u,
            d,
            q,
        }
    }
}

/// Return a 32-byte hash of the given data
pub fn hash_bytes(data: &[u8]) -> [u8; 32] {
    let mut hasher = Blake2bVar::new(32).expect("Failed to construct hasher!");
    hasher.update(data);
    let mut buf = [0u8; 32];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}

/// Return 32-byte hash of the given list of data
pub fn combine_hashes(hash_list: Vec<Vec<u8>>) -> [u8; 32] {
    let mut hasher = Blake2bVar::new(32).expect("Failed to construct hasher!");
    for data in hash_list.iter() {
        hasher.update(data);
    }
    let mut buf = [0u8; 32];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}

/// Generate a set of items for given set size
/// Items are generated by hashing the current index
pub fn gen_items(size: u8) -> Vec<[u8; 32]> {
    let mut s_p = Vec::with_capacity(size as usize);
    for b in 0..size {
        let b_arr = [b];
        let item = hash_bytes(&b_arr);
        s_p.push(item);
    }
    s_p
}

fn oracle(hash: &[u8], n: usize) -> usize {
    if n.is_power_of_two() {
        mod_power_of_2(hash, n)
    } else {
        mod_non_power_of_2(hash, n)
    }
}

fn prove(s_p: &Vec<[u8; 32]>, params: &Params) -> Proof {
    let setup = AlbaSetup::gen_setup(params);

    let mut pre_hash_list: Vec<PreHash> = Vec::new();

    // Generate prehash list including the item itself, hash of the item and oracle output of hash and n_p
    for s in s_p {
        let h = hash_bytes(s);
        let l = oracle(&h, params.n_p);
        pre_hash_list.push(PreHash {
            s: *s,
            h: h.to_vec(),
            l,
        });
    }

    let mut round_stack: Vec<Round> = Vec::new();
    let prob_q = setup
        .q
        .inv()
        .ceil()
        .to_usize()
        .expect("Failed to compute prob_q");

    // For each item in pre_hash_list, try d times
    // If l and the new_np are equal then create a new round entry
    for shl in &pre_hash_list {
        for t in 1..setup.d + 1 {
            let hash_t = hash_bytes(&[t as u8]).to_vec();
            let new_h = combine_hashes([hash_t, shl.h.clone()].to_vec());
            let new_np = oracle(&new_h, params.n_p);
            if shl.l == new_np {
                round_stack.push(Round {
                    t,
                    h: new_h.to_vec(),
                    s_list: vec![shl.s],
                    n_p: new_np,
                })
            }
        }
    }
    // Try to generate a proof for each entry of round stack
    for round in round_stack.iter() {
        if let Some(proof) = go(
            setup.u - 2,
            &pre_hash_list,
            round.clone(),
            prob_q,
            setup.n_p,
        ) {
            return proof;
        }
    }
    Proof {
        d: 0,
        items: vec![],
    }
}

fn go(
    k: usize,
    pre_hash_list: &[PreHash],
    round: Round,
    prob_q: usize,
    n_p: usize,
) -> Option<Proof> {
    if k == 0 && !pre_hash_list.is_empty() {
        let (shl, rest) = pre_hash_list.split_at(1);
        let shl = &shl[0]; // Let (s_i, (h_si, _)) = items[0]
        let new_h = combine_hashes([round.h.clone(), shl.h.clone()].to_vec());
        let new_np = oracle(&new_h, prob_q); // Let n_pj' = oracle(h_i, prob_q)

        if new_np == 0 {
            let mut items: Vec<[u8; 32]> = Vec::new();
            items.push(shl.s);
            items.extend(round.s_list);
            return Some(Proof { d: round.t, items }); // Return the Proof here
        } else {
            return go(0, rest, round.clone(), prob_q, n_p);
        }
    }

    if pre_hash_list.is_empty() {
        return None;
    }

    if k > 0 && !pre_hash_list.is_empty() {
        let (shl, rest) = pre_hash_list.split_at(1);
        let shl = &shl[0]; // Let (s_i, (h_si, _)) = items[0]
        let new_h = combine_hashes([round.h.clone(), shl.h.clone()].to_vec());

        if shl.l == round.n_p {
            let mut items: Vec<[u8; 32]> = Vec::new();
            items.push(shl.s);
            items.extend(round.s_list.clone());
            let new_np = oracle(&new_h, n_p);
            let new_round = Round {
                t: round.t,
                h: new_h.to_vec(),
                s_list: items,
                n_p: new_np,
            };
            return match go(k - 1, pre_hash_list, new_round, prob_q, n_p) {
                Some(result) => Some(result),
                None => go(k, rest, round, prob_q, n_p),
            };
        }
        return go(k, rest, round, prob_q, n_p);
    }
    None
}

// Helpers
fn mod_non_power_of_2(hash: &[u8], n: usize) -> usize {
    let epsilon_fail: usize = 1 << 40; // roughly 1 in 10 billion
    let k = log_base2(n * epsilon_fail);
    let k_prime = 1 << k;
    let d = k_prime / n;

    let i = mod_power_of_2(hash, k_prime);

    if i >= d * n {
        panic!("failed: i = {}, d = {}, n = {}, k = {}", i, d, n, k);
    } else {
        i % n
    }
}
fn mod_power_of_2(hash: &[u8], n: usize) -> usize {
    let r = from_bytes_le(hash);
    (n - 1) & r
}
fn log_base2(x: usize) -> usize {
    usize::BITS as usize - x.leading_zeros() as usize - 1
}
fn from_bytes_le(bytes: &[u8]) -> usize {
    let mut array = [0u8; 8];
    let bytes = &bytes[..min(8, bytes.len())];
    array[..bytes.len()].copy_from_slice(bytes);
    usize::from_le_bytes(array)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn try_prove() {
        let params = Params {
            lambda_sec: 128.0,
            lambda_rel: 128.0,
            n_p: 80,
            n_f: 20,
        };
        // let alba_setup = AlbaSetup::gen_setup(&params);
        let s_p = gen_items(100);

        let proof = prove(&s_p, &params);
        println!("{}", proof.d);
    }
}
