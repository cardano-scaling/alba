use blake2::digest::{Update, VariableOutput};
use blake2::Blake2bVar;
use std::cmp::min;

/// Binary Random Oracles (c.f. Appendix B, Alba paper)
/// Takes as input a hash and inverse probability and returns an integer
pub fn oracle(hash: &[u8], n: usize) -> usize {
    if n.is_power_of_two() {
        mod_power_of_2(hash, n)
    } else {
        mod_non_power_of_2(hash, n)
    }
}

fn mod_non_power_of_2(hash: &[u8], n: usize) -> usize {
    fn log_base2(x: usize) -> usize {
        usize::BITS as usize - x.leading_zeros() as usize - 1
    }
    let epsilon_fail: usize = 1 << 40; // roughly 1 in 10 billion
    let k: usize = log_base2(n * epsilon_fail);
    let k_prime: usize = 1 << k;
    let d: usize = k_prime.div_ceil(n);

    let i = mod_power_of_2(hash, k_prime);

    if i >= d * n {
        panic!("failed: i = {}, d = {}, n = {}, k = {}", i, d, n, k);
    } else {
        i % n
    }
}

fn mod_power_of_2(hash: &[u8], n: usize) -> usize {
    fn from_bytes_le(bytes: &[u8]) -> usize {
        let mut array = [0u8; 8];
        let bytes = &bytes[..min(8, bytes.len())];
        array[..bytes.len()].copy_from_slice(bytes);
        usize::from_le_bytes(array)
    }
    let r = from_bytes_le(hash);
    (n - 1) & r
}


// Hash helpers

/// Return a N-byte long hash of the given data
pub fn hash_bytes<const N: usize>(data: &[u8]) -> [u8; N] {
    let mut hasher = Blake2bVar::new(N).expect("Failed to construct hasher!");
    hasher.update(data);
    let mut buf = [0u8; N];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}

/// Return a N-byte long hash of the given list of data
pub fn combine_hashes<const N: usize>(hash_list: Vec<Vec<u8>>) -> [u8; N] {
    let mut hasher = Blake2bVar::new(N).expect("Failed to construct hasher!");
    for data in hash_list.iter() {
        hasher.update(data);
    }
    let mut buf = [0u8; N];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}


// Test & Bench helpers

/// Generate a set of items given the set size and a seed
/// Items are generated by hashing the current index
pub fn gen_items<const N: usize>(seed: Vec<u8>, set_size: usize) -> Vec<[u8; N]> {
    let mut s_p = Vec::with_capacity(set_size);
    for b in 0..set_size {
        let mut data = Vec::new();
        data.push(seed.clone());
        data.push(b.to_ne_bytes().to_vec());
        let item = combine_hashes::<N>(data);
        s_p.push(item);
    }
    s_p
}
