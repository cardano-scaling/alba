//! Approximate Lower Bound Arguments (ALBA, <https://eprint.iacr.org/2023/1655.pdf>)
//!
//! Alba is a generic protocol to prove succinctly a lower bound of the size of
//! a, potentially weighted, set. Say we have a set Sp of size |Sp| >= $n_p$,
//! and a lower bound $n_f$ < $n_p$ of it we want to prove. Alba gives us a
//! method to generate a proof of knowledge of this bound by finding the
//! smallest subset of Sp of size $u$ to convince a verifier.
//! The paper presents several schemes and optimizations. The basic scheme is
//! enhanced in the "prehashed" version thanks to sorting Sp with a balls and
//! bins sorting algorithm reducing the number of hashes done per round. A
//! lottery scheme is also introduced to support Alba in a decentralised
//! settings as well as a modification to use PRF in the CRS settings instead of
//! using the ROM.
//! Rust implementation of ALBA's bounded DFS scheme using Blake2b as hash
//! function.

use blake2::digest::{Update, VariableOutput};
use blake2::Blake2bVar;
use rand::Rng;
use std::cmp::min;

// Helper functions
fn mod_non_power_of_2(hash: &[u8], n: usize) -> usize {
    let epsilon_fail: usize = 1 << 40; // roughly 1 in 10 billion
    let k = log_base2(n * epsilon_fail);
    let k_prime = 1 << k;
    let d = k_prime / n;

    let i = mod_power_of_2(hash, k_prime);

    if i >= d * n {
        panic!("failed: i = {}, d = {}, n = {}, k = {}", i, d, n, k);
    } else {
        i % n
    }
}

fn mod_power_of_2(hash: &[u8], n: usize) -> usize {
    let r = from_bytes_le(hash);
    (n - 1) & r
}

fn log_base2(x: usize) -> usize {
    usize::BITS as usize - x.leading_zeros() as usize - 1
}

fn from_bytes_le(bytes: &[u8]) -> usize {
    let mut array = [0u8; 8];
    let bytes = &bytes[..min(8, bytes.len())];
    array[..bytes.len()].copy_from_slice(bytes);
    usize::from_le_bytes(array)
}

/// Return a 32-byte hash of the given data
pub fn hash_bytes(data: &[u8]) -> [u8; 32] {
    let mut hasher = Blake2bVar::new(32).expect("Failed to construct hasher!");
    hasher.update(data);
    let mut buf = [0u8; 32];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}

/// Return 32-byte hash of the given list of data
pub fn combine_hashes(hash_list: Vec<Vec<u8>>) -> [u8; 32] {
    let mut hasher = Blake2bVar::new(32).expect("Failed to construct hasher!");
    for data in hash_list.iter() {
        hasher.update(data);
    }
    let mut buf = [0u8; 32];
    hasher
        .finalize_variable(&mut buf)
        .expect("Failed to finalize hashing");
    buf
}

pub fn oracle(hash: &[u8], n: usize) -> usize {
    if n.is_power_of_two() {
        mod_power_of_2(hash, n)
    } else {
        mod_non_power_of_2(hash, n)
    }
}

/// Generate a set of items for given set size
/// Items are generated by hashing the current index
pub fn gen_items(size: usize) -> Vec<[u8; 32]> {
    let mut s_p = Vec::with_capacity(size);
    let mut rng = rand::thread_rng();
    let seed = rng.gen_range(0..u32::MAX);
    for b in 0..size {
        let mut data = Vec::new();
        data.push(seed.to_ne_bytes().to_vec());
        data.push(b.to_ne_bytes().to_vec());
        let item = combine_hashes(data);
        s_p.push(item);
    }
    s_p
}

extern crate core;


use std::f64::consts::E;

/// Setup input parameters
#[derive(Debug, Clone)]
pub struct Params {
    /// Soundness security parameter
    pub lambda_sec: usize,
    /// Completeness security parameter
    pub lambda_rel: usize,
    /// Approximate size of set Sp to lower bound
    pub n_p: usize,
    /// Target lower bound
    pub n_f: usize,
}
/// Setup output parameters
#[derive(Debug, Clone)]
pub struct Setup {
    /// Approximate size of set Sp to lower bound
    pub n_p: usize,
    /// Proof size (in Sp elements)
    pub u: usize,
    /// Proof max counter
    pub d: usize,
    /// Inverse of probability p_q
    pub q: usize,
}
impl Setup {
    /// Setup algorithm taking a Params as input and returning setup parameters (u,d,q)
    pub fn new(params: &Params) -> Self {
        // Misc values
        let e = E;
        let log_2 = |x: f64| x.log2();
        let loge = log_2(e);
        let logloge = log_2(loge);
        let log3 = log_2(3.0);
        let log12 = log_2(12.0);

        // Converting params to f64
        let n_p_f64 = params.n_p as f64;
        let n_f_f64 = params.n_f as f64;
        let lognpnf = log_2(n_p_f64 / n_f_f64);
        let lambda_sec = params.lambda_sec as f64;
        let lambda_rel = params.lambda_rel as f64;

        // Initialising output params
        let u;
        let d;
        let q;

        // If $n_p$ < λ^3, we define the parameters accoding to Section 3.2.2, Theorem 12 and Corollary 3
        if n_p_f64 < (lambda_rel * lambda_rel * lambda_rel) {
            let u_f64 = (lambda_sec + log_2(lambda_rel) + 5.0 - logloge) / lognpnf;
            u = u_f64.ceil() as usize;
            let d_f64 = 32.0 * log12 * u_f64;
            d = d_f64.ceil() as usize;
            q = ((2.0 * log12) / d_f64).recip().ceil() as usize;
        } else {
            // Otherwise, according to Section 3.2, Corrollary 2
            let u_f64 = (lambda_sec + log_2(lambda_rel + log3) + 1.0 - logloge) / lognpnf;
            u = u_f64.ceil() as usize;
            let d_f64 = 16.0 * u_f64 * (lambda_rel + log3) / loge;
            d = d_f64.ceil() as usize;
            q = (2.0 * (lambda_rel + log3) / (d_f64 * loge)).recip().ceil() as usize;

            let check = ((d_f64 * d_f64 * loge) / (9.0 * (lambda_rel + log3))).ceil() as usize;
            assert!(params.n_p >= check);
        }

        Setup {
            n_p: params.n_p,
            u,
            d,
            q,
        }
    }
}

/// Round parameters
#[derive(Debug, Clone)]
pub struct Round {
    /// Proof counter
    t: usize,
    // Round candidate tuple
    s_list: Vec<[u8; 32]>,
    /// Round candidate hash
    h: Vec<u8>,
    /// Round candidate hash mapped to [1, n_p]
    h_usize: usize,
    /// Approximate size of set Sp to lower bound
    n_p: usize,
}

impl Round {
    /// Oracle producing a uniformly random value in [1, n_p] used for round candidates
    /// We also return hash(data) to follow the optimization presented in Section 3.3
    fn h1(data: Vec<Vec<u8>>, n_p: usize) -> ([u8; 32], usize) {
        let digest = combine_hashes(data);
        return (digest, oracle(&digest, n_p));
    }

    /// Output a round from a proof counter and n_p
    /// Initilialises the hash with H1(t) and random value as oracle(H1(t), n_p)
    pub fn new(t: usize, n_p: usize) -> Round {
        let data = [t.to_ne_bytes().to_vec()].to_vec();
        let (h, h_usize) = Round::h1(data, n_p);
        Round {
            t,
            s_list: Vec::new(),
            h: h.to_vec(),
            h_usize,
            n_p,
        }
    }

    /// Updates a round with an element of S_p
    /// Replaces the hash $h$ with $h' = H1(h, s)$ and the random value as oracle(h', n_p)
    pub fn update(r: &Round, s: [u8; 32]) -> Round {
        let mut s_list = r.s_list.clone();
        s_list.push(s);
        let mut data = Vec::new();
        data.push(r.h.clone());
        data.push(s.to_vec());
        let (h, h_usize) = Round::h1(data, r.n_p);
        Round {
            t: r.t,
            s_list,
            h: h.to_vec(),
            h_usize,
            n_p: r.n_p,
        }
    }
}

#[derive(Debug, Clone)]
/// Alba proof
pub struct Proof {
    /// Proof counter
    d: usize,
    /// Proof tuple
    items: Vec<[u8; 32]>,
}

impl Proof {
    /// Oracle producing a uniformly random value in [1, n_p] used for prehashing S_p
    // TODO: We also return hash(data) to follow the optimization presented in Section 3.3
    fn h0(setup: &Setup, s: [u8; 32]) -> usize {
        let mut data = Vec::new();
        data.push(s.to_vec());
        let digest = combine_hashes(data);
        // return (digest, oracle(&digest, setup.n_p));
        return oracle(&digest, setup.n_p);
    }

    /// Oracle defined as Bernoulli(q) returning 1 with probability q and 0 otherwise
    fn h2(setup: &Setup, r: &Round) -> bool {
        let mut data = Vec::new();
        data.push(r.t.to_ne_bytes().to_vec());
        for s in &r.s_list {
            data.push(s.clone().to_vec());
        }
        let digest = combine_hashes(data);
        return oracle(&digest, setup.q) == 0;
    }

    /// Depth-first search which goes through all potential round candidates
    /// and returns first round candidate Round{t, x_1, ..., x_u)} such that:
    /// - for all i ∈ [0, u-1], H0(x_i+1) ∈ bins[H1(t, x_1, ..., x_i)]
    /// - H2(t, x_0, ..., x_u) = true
    fn dfs(setup: &Setup, bins: &Vec<Vec<[u8; 32]>>, round: &Round) -> Option<Proof> {
        // If the round candidate is at the last iteration (len(round) == u)
        if round.s_list.len() == setup.u {
            // if H2(t, x_0, ..., x_u) = true, return candidate as proof
            if Proof::h2(setup, round) {
                let d = round.t;
                let items = round.s_list.clone();
                return Some(Proof { d, items });
            } else {
                return None;
            }
        }
        // Otherwise, update round candidate with all s in bins[H1(t, x_1, ..., x_i)] and continue
        let result = bins[round.h_usize]
            .iter()
            .find_map(|&s| Self::dfs(setup, bins, &Round::update(round, s)));
        return result;
    }

    /// Alba's proving algorithm, based on a depth-first search algorithm.
    /// Returns an empty proof if no suitable candidate is found.
    pub fn prove(setup: &Setup, set: &Vec<[u8; 32]>) -> Self {
        // Initialising our n_p bins with all s ∈ Sp
        let mut bins: Vec<Vec<[u8; 32]>> = Vec::new();
        for _ in 1..(setup.n_p + 1) {
            bins.push(Vec::new());
        }
        for &s in set.iter() {
            // TODO: add H1(s)
            // let (hs, index_s) = Proof::h0(setup, s);
            bins[Proof::h0(setup, s)].push(s);
        }

        // Attempting to generate a proof for $d$ rounds
        for t in 1..(setup.d + 1) {
            let round = Round::new(t, setup.n_p);
            if let Some(proof) = Proof::dfs(setup, &bins, &round) {
                return proof;
            };
        }

        // If no proof found, return empty proof
        return Proof {
            d: 0,
            items: Vec::new(),
        };
    }

    /// Alba's verification algorithm, follows proving algorithm by running the
    /// same depth-first search algorithm.
    pub fn verify(setup: &Setup, proof: Proof) -> bool {
        if proof.d == 0 || proof.d > setup.d || proof.items.len() != setup.u {
            return false;
        }
        let r0 = Round::new(proof.d, setup.n_p);
        let (b, round) = proof.items.iter().fold((true, r0), |(b, r), &s| {
            (b && r.h_usize == Proof::h0(setup, s), Round::update(&r, s))
        });
        return b && Proof::h2(setup, &round);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_verify() {
        let s_p = gen_items(100);
        let params = Params {
            lambda_sec: 10,
            lambda_rel: 10,
            n_p: 80,
            n_f: 20,
        };
        let setup = Setup::new(&params);
        let proof = Proof::prove(&setup, &s_p);
        assert!(Proof::verify(&setup, proof.clone()));
        let proof_0 = Proof {
            d: 0,
            items: proof.items.clone(),
        };
        assert!(!Proof::verify(&setup, proof_0));
        let proof_d = Proof {
            d: 1_000_000,
            items: proof.items.clone(),
        };
        assert!(!Proof::verify(&setup, proof_d));
        let proof_item = Proof {
            d: proof.d,
            items: Vec::new(),
        };
        assert!(!Proof::verify(&setup, proof_item));
        let mut wrong_items = proof.items.clone();
        let _ = wrong_items.pop();
        let proof_itembis = Proof {
            d: proof.d,
            items: wrong_items.clone(),
        };
        assert!(!Proof::verify(&setup, proof_itembis));
        wrong_items.push([0u8; 32]);
        let proof_itembis = Proof {
            d: proof.d,
            items: wrong_items,
        };
        assert!(!Proof::verify(&setup, proof_itembis));
    }

    #[test]
    fn test_prove() {
        use std::time::Instant;
        println!("\n------------------------- Bench prehashed");
        let nb_tests = 10;
        let lengths = [100];
        let secs = [10, 20, 40];
        for l in lengths {
            let mut u = 0;
            let mut time_setup = 0;
            let mut time_prove = 0;
            let mut time_verify = 0;
            for s in secs {
                let s_p: Vec<[u8; 32]> = gen_items(l);
                for _t in 0..nb_tests {
                    let params = Params {
                        lambda_sec: s,
                        lambda_rel: s,
                        n_p: 80,
                        n_f: 20,
                    };
                    // Setup
                    let start_setup = Instant::now();
                    let setup = Setup::new(&params);
                    let end_setup = start_setup.elapsed();
                    time_setup += end_setup.as_micros();
                    u = setup.u;
                    // Prove
                    let start_prove = Instant::now();
                    let proof = Proof::prove(&setup, &s_p);
                    let end_prove = start_prove.elapsed();
                    time_prove += end_prove.as_millis();
                    // Verify
                    let start_verify = Instant::now();
                    let b = Proof::verify(&setup, proof.clone());
                    let end_verify = start_verify.elapsed();
                    time_verify += end_verify.as_millis();
                    assert!(b);
                }

                println!(
                    "l:{} s:{} u:{}: \t setup {}mus \t prove:{}ms \t verify:{}ms",
                    l,
                    s,
                    u,
                    time_setup / nb_tests,
                    time_prove / nb_tests,
                    time_verify / nb_tests
                );
            }
        }
        assert!(false);
    }
}

